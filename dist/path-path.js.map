{"version":3,"file":"path-path.js","sources":["../src/index.js"],"sourcesContent":["const CAPTURE = /^\\:([^\\?\\.]+)(\\?|(?:\\.){3}){0,1}$/;\r\nconst FOLDERS = /([^\\/]+)/g;\r\nconst FOLDER = \"[^\\\\/]\";\r\nconst SPLIT = \"(?:\\\\/){0,1}\";\r\n\r\nexport function join(a = \"\", b = \"\") {\r\n    return (a + \"<?>\" + b).replace(/(\\/){0,1}\\<\\?\\>(\\/){0,1}/, \"/\");\r\n}\r\n\r\nfunction relative(str) {\r\n    let dotdot = /\\/[^\\/]+\\/(\\.){2}/,\r\n        dot = /\\/(\\.){1}/;\r\n    str = str.replace(dotdot, \"\");\r\n    if (dotdot.test(str)) str = relative(str);\r\n    str = str.replace(dot, \"\");\r\n    if (dotdot.test(str)) str = relative(str);\r\n    return str;\r\n}\r\n\r\nexport function getSearch(search, params = {}) {\r\n    search = search.match(/[^\\&]+/g) || [];\r\n    return search.reduce((params, item) => {\r\n        let position = item.search(\"=\"),\r\n            param = item.slice(0, position >>> 0),\r\n            value = position > -1 ? item.slice(position + 1) : undefined;\r\n        params[param] = value;\r\n        return params;\r\n    }, params);\r\n}\r\n\r\nexport function create(path) {\r\n    let folders = [\"^\"],\r\n        params = [],\r\n        status = path.match(FOLDERS);\r\n    if (status) {\r\n        status.some(folder => {\r\n            let status = folder.match(CAPTURE);\r\n            if (status) {\r\n                let [all, param, option] = status;\r\n                params.push(param);\r\n                switch (option) {\r\n                    case \"?\":\r\n                        folders.push(`${SPLIT}(${FOLDER}*)`);\r\n                        break;\r\n                    case \"...\":\r\n                        folders.push(`(.*)`);\r\n                        return true;\r\n                    default:\r\n                        folders.push(`\\\\/(${FOLDER}+)`);\r\n                }\r\n            } else {\r\n                folders.push(\r\n                    `\\\\/${\r\n                        folder == \"**\"\r\n                            ? `${FOLDER}+`\r\n                            : folder.replace(/([^\\w\\d])/g, \"\\\\$1\")\r\n                    }`\r\n                );\r\n            }\r\n        });\r\n    } else {\r\n        folders.push(SPLIT);\r\n    }\r\n    return {\r\n        path: path,\r\n        regExp: RegExp(folders.join(\"\") + \"$\"),\r\n        params\r\n    };\r\n}\r\n\r\nexport function resolve(origin, merge) {\r\n    let folders = [\"\"];\r\n\r\n    merge =\r\n        merge[0] === \"/\"\r\n            ? merge\r\n            : origin + (origin[origin.length] === \"/\" ? \"\" : \"/\") + merge;\r\n\r\n    origin = origin.match(FOLDERS) || [];\r\n    merge = relative(merge).match(FOLDERS) || [];\r\n\r\n    for (let i = 0; i < merge.length; i++) {\r\n        let status = merge[i].match(CAPTURE),\r\n            option = status ? status[2] : merge[i];\r\n\r\n        switch (option) {\r\n            case \"?\":\r\n                if (origin[i]) folders.push(origin[i]);\r\n                break;\r\n            case \"...\":\r\n                folders = folders.concat(origin.slice(i));\r\n                break;\r\n            default:\r\n                folders.push(\r\n                    status || merge[i] === \"**\" ? origin[i] : merge[i]\r\n                );\r\n        }\r\n    }\r\n\r\n    return folders.join(\"/\");\r\n}\r\n\r\nexport function compare(router, path, params = {}) {\r\n    let query = path.match(/(?:\\/){0,1}\\?(.*)/);\r\n    if (query) {\r\n        params.query = getSearch(query[1]);\r\n        path = path.slice(0, query.index);\r\n    }\r\n    let status = path.match(router.regExp);\r\n\r\n    if (status) {\r\n        status.slice(1).forEach((value, index) => {\r\n            params[router.params[index]] = value;\r\n        });\r\n        return params;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n"],"names":["const","CAPTURE","FOLDERS","FOLDER","SPLIT","getSearch","search","params","match","reduce","item","let","position","param","slice","value","undefined","a","b","replace","path","folders","status","some","folder","push","option","regExp","RegExp","join","origin","merge","length","relative","str","dotdot","test","i","concat","router","query","index","forEach"],"mappings":"AAAAA,IAAMC,EAAU,oCACVC,EAAU,YACVC,EAAS,SACTC,EAAQ,eAgBP,SAASC,EAAUC,EAAQC,GAE9B,2BADAD,EAASA,EAAOE,MAAM,gBACRC,gBAAQF,EAAQG,GAC1BC,IAAIC,EAAWF,EAAKJ,OAAO,KACvBO,EAAQH,EAAKI,MAAM,EAAGF,IAAa,GACnCG,EAAQH,GAAY,EAAIF,EAAKI,MAAMF,EAAW,QAAKI,EAEvD,OADAT,EAAOM,GAASE,EACTR,GACRA,gBAtBA,SAAcU,EAAQC,GACzB,sBADqB,mBAAQ,KACrBD,EAAI,MAAQC,GAAGC,QAAQ,2BAA4B,yCAwBxD,SAAgBC,GACnBT,IAAIU,GAAW,KACXd,KACAe,EAASF,EAAKZ,MAAMN,GA8BxB,OA7BIoB,EACAA,EAAOC,cAAKC,GACRb,IAAIW,EAASE,EAAOhB,MAAMP,GAC1B,GAAIqB,EAAQ,CACR,WAEA,OADAf,EAAOkB,WACCC,GACJ,IAAK,IACDL,EAAQI,KAAQrB,MAASD,QACzB,MACJ,IAAK,MAED,OADAkB,EAAQI,KAAK,SACN,EACX,QACIJ,EAAQI,YAAYtB,cAG5BkB,EAAQI,YAEU,MAAVD,EACSrB,MACHqB,EAAOL,QAAQ,aAAc,YAMnDE,EAAQI,KAAKrB,IAGbgB,KAAMA,EACNO,OAAQC,OAAOP,EAAQQ,KAAK,IAAM,YAClCtB,oBAID,SAAiBuB,EAAQC,GAC5BpB,IAAIU,GAAW,IAEfU,EACiB,MAAbA,EAAM,GACAA,EACAD,GAAoC,MAA1BA,EAAOA,EAAOE,QAAkB,GAAK,KAAOD,EAEhED,EAASA,EAAOtB,MAAMN,OACtB6B,EAtEJ,SAASE,EAASC,GACdvB,IAAIwB,EAAS,oBAMb,OAJAD,EAAMA,EAAIf,QAAQgB,EAAQ,IACtBA,EAAOC,KAAKF,KAAMA,EAAMD,EAASC,IACrCA,EAAMA,EAAIf,QAHA,YAGa,IACnBgB,EAAOC,KAAKF,KAAMA,EAAMD,EAASC,IAC9BA,EA+DCD,CAASF,GAAOvB,MAAMN,OAE9B,IAAKS,IAAI0B,EAAI,EAAGA,EAAIN,EAAMC,OAAQK,IAAK,CACnC1B,IAAIW,EAASS,EAAMM,GAAG7B,MAAMP,GAG5B,OAFaqB,EAASA,EAAO,GAAKS,EAAMM,IAGpC,IAAK,IACGP,EAAOO,IAAIhB,EAAQI,KAAKK,EAAOO,IACnC,MACJ,IAAK,MACDhB,EAAUA,EAAQiB,OAAOR,EAAOhB,MAAMuB,IACtC,MACJ,QACIhB,EAAQI,KACJH,GAAuB,OAAbS,EAAMM,GAAcP,EAAOO,GAAKN,EAAMM,KAKhE,OAAOhB,EAAQQ,KAAK,sBAGxB,SAAwBU,EAAQnB,EAAMb,sBAClCI,IAAI6B,EAAQpB,EAAKZ,MAAM,qBACnBgC,IACAjC,EAAOiC,MAAQnC,EAAUmC,EAAM,IAC/BpB,EAAOA,EAAKN,MAAM,EAAG0B,EAAMC,QAE/B9B,IAAIW,EAASF,EAAKZ,MAAM+B,EAAOZ,QAE/B,QAAIL,IACAA,EAAOR,MAAM,GAAG4B,iBAAS3B,EAAO0B,GAC5BlC,EAAOgC,EAAOhC,OAAOkC,IAAU1B,IAE5BR"}